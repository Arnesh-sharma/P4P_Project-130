%% PLOT LIVE ADC TRANSFER CURVE
% This script loads a saved baseline, then continuously collects new data
% and plots the live ADC values against the IDAC step value.

% --- Clean slate ---
clear; clc; close all;

% --- Configuration ---
port = "COM7";      % <-- IMPORTANT: Change to your PSoC's COM port
baud = 115200;      % <-- IMPORTANT: Match your PSoC's UART baud rate
term = "CR/LF";     % Terminator for \r\n from PSoC
baseline_filename = 'baseline_data.mat'; % The baseline file to load

% --- Data Collection Parameters ---
IDAC_MAX_VALUE = 255;
NUM_STEPS = IDAC_MAX_VALUE + 1;

% --- Load the Baseline Data ---
% Note: The baseline is loaded but no longer used in the plot itself,
% but it's kept here in case you want to use it for other logic.
try
    fprintf('Loading baseline data from %s...\n', baseline_filename);
    loaded_data = load(baseline_filename);
    baseline_adc_results = loaded_data.raw_adc_results;
    disp('Baseline loaded successfully.');
catch
    error('Could not load baseline file: %s.', baseline_filename);
end

% --- Setup Plot for Live Updating ---
figure;
hold on;
grid on;
title('Live ADC Transfer Curve'); % CHANGED: Updated title
xlabel('ADC Value (Counts)');          % CHANGED: X-axis is now ADC values
ylabel('IDAC Step Value');             % CHANGED: Y-axis is now IDAC values
ylim([0 IDAC_MAX_VALUE]);              % CHANGED: Set Y-axis limit
% Optional: Set a sensible X-limit based on your ADC's bit depth
% For a 12-bit ADC, the range is 0-4095. Uncomment and adjust as needed.
% xlim([0 4095]); 

% Create the plot with ADC on X-axis and IDAC on Y-axis
hPlot = plot(zeros(NUM_STEPS, 1), 0:IDAC_MAX_VALUE, '.-'); % CHANGED: Swapped X and Y data
disp('Starting live plotting. Press Ctrl+C in the Command Window to stop.');

% --- Setup Serial Port and Start Live Collection ---
try
    s = serialport(port, baud);
    configureTerminator(s, term);
    
    current_adc_results = zeros(NUM_STEPS, 1);

    % --- Main Loop for Continuous Plotting ---
    while true % Loop forever until stopped with Ctrl+C
        flush(s);
        fprintf('Collecting new sweep...\n');

        for idac_step = 0:IDAC_MAX_VALUE
            received_correct_step = false;
            while ~received_correct_step
                line = readline(s);
                vals = sscanf(line, 'IDAC Val: %f, Pin Val: %f');
                if numel(vals) == 2 && round(vals(1)) == idac_step
                    current_adc_results(idac_step + 1) = vals(2);
                    received_correct_step = true;
                end
            end
        end

        % --- Analysis and Plotting ---
        % The difference is still calculated but is not plotted in this version.
        adc_difference = current_adc_results - baseline_adc_results;

        % Update the plot's X-Data with the new ADC readings
        set(hPlot, 'XData', current_adc_results); % CHANGED: Update XData instead of YData
        
        % Force MATLAB to draw the updated plot
        drawnow;
    end
    
catch ME
    disp('Script stopped. Closing serial port.');
    clear s;
    if ~strcmp(ME.identifier, 'MATLAB:serialport:readline:OperationTerminated')
        rethrow(ME);
    end
end